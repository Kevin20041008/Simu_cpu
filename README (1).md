# PriorityInterruptCPU

一个用 **Python** 实现的、带**可屏蔽优先级中断**与**中断嵌套**能力的 8 位教学 CPU 模拟器。  
特点：简单、可读、纯标准库，无需依赖，适合学习“指令周期 / 标志位 / 栈 / 调用返回 / 中断优先级与嵌套”等概念。

> 代码文件：`PriorityInterruptCPU` 类（单文件示例含 `__main__` 演示）  
> 语言：Python 3.8+（推荐 3.10+）

---

## 目录
- [功能特性](#功能特性)
- [快速开始](#快速开始)
- [核心设计](#核心设计)
- [内存与寄存器](#内存与寄存器)
- [中断系统](#中断系统)
- [指令集](#指令集)
- [示例程序](#示例程序)
- [扩展与开发](#扩展与开发)
- [常见问题](#常见问题)
- [Roadmap](#roadmap)
- [许可证](#许可证)

---

## 功能特性

- 8 位寄存器：`A, B, C, D, PC, SP, FLAGS`  
- 256 字节内存 + 16 字节栈
- **优先级中断队列**（`PriorityQueue`）与**中断屏蔽**、**中断嵌套**
- 简化版**中断向量表**（0x00–0x07），内置 4 个中断服务例程（ISR）
- 算术/逻辑/移位/跳转/栈/数据传输/比较/输入/中断 等指令
- 纯标准库（`threading / time / queue`），跨平台可运行

---

## 快速开始

> 假设你把示例保存为 `priority_interrupt_cpu.py`（包含 `if __name__ == "__main__":` 的演示代码）

```bash
# 1) 克隆仓库
git clone https://github.com/<your-name>/<your-repo>.git
cd <your-repo>

# 2) 运行示例（纯标准库，无需安装依赖）
python3 priority_interrupt_cpu.py
```

运行后你会看到：
- 主程序自增寄存器 A 并循环
- 后台线程依次触发 **低优先级 → 高优先级 → 最高优先级** 的中断
- CPU 会按优先级打断与嵌套执行 ISR
- 最终打印寄存器与内存映射区（0xF0–0xF3）的结果

---

## 核心设计

- **取指/执行循环**：`execute()` 内部轮询中断 → 取 opcode → 分发到 `instructions` 表中对应的成员方法  
- **指令实现**：以方法实现，每条指令返回 `True/False` 控制继续/停止；`update_flags()` 更新 Z/S/C 等标志  
- **中断检查**：`check_interrupt()` 从优先队列选择**当前处理中断之上**的最高优先级中断  
- **中断处理**：`handle_interrupt()` 将 `PC/FLAGS/当前优先级` 压栈、跳转到向量表指定的 ISR；`iret()` 依序恢复

---

## 内存与寄存器

- **内存**：256 字节（`self.memory`）
  - `0x00–0x07`：中断向量表（每个向量 2 字节：低位在前，高位在后）
  - `0x20/0x30/0x40/0x50`：内置 ISR 起始地址
  - `0x60`：示例主程序装载地址
  - `0xF0–0xF3`：示例中作为“内存映射寄存器/状态区”
- **栈**：16 字节（`self.stack`），`SP` 指向**下一个可写入位置**（从 0 递增）
- **寄存器**：
  - 通用：`A, B, C, D`（8 位）
  - 流控：`PC`（16 位，但内存 8 位寻址，示例仅用低 8 位），`SP`（0–16）
  - 标志：`FLAGS`  
    - `0x01`：C（进位/借位）  
    - `0x02`：Z（零）  
    - `0x04`：S（符号/负号）  
    - `0x08`：I（中断允许）

---

## 中断系统

- **优先级**：`0`（最高）→ `7`（最低）。示例映射：
  - 向量 0 → 优先级 0（复位/最高）
  - 向量 1 → 优先级 2（硬故障/高）
  - 向量 2 → 优先级 4（定时器/中）
  - 向量 3 → 优先级 6（I/O/低）
- **屏蔽**：`interrupt_mask`（8 位位图，1=允许，0=屏蔽），以及全局 `interrupt_enabled`
- **嵌套**：进入 ISR 时保存“当前优先级”，仅允许**更高**优先级中断再打断（`nesting_level` 计数）
- **保存现场**（进入 ISR）：
  1. `PC low → PC high → FLAGS → current_priority` 依次压栈
  2. 设为新的 `current_priority`，跳转到向量表指定地址
- **恢复**（`IRET`）：
  1. 依次弹出 `saved_priority → FLAGS → PC high → PC low`
  2. 恢复 `PC / FLAGS / current_priority / interrupt_enabled`

---

## 指令集

> **操作码 (Hex)**  → **助记符**  → **说明**

### 基本
- `00` HLT 停机  
- `01` LDA #imm  
- `02` LDB #imm  
- `03` LDC #imm  
- `04` LDD #imm  
- `05` STA addr  
- `06` STB addr  
- `07` STC addr  
- `08` STD addr  
- `09` ADD（A=A+B，设 C/Z/S）  
- `0A` SUB（A=A−B，借位设 C）  
- `0B` MUL（低 8 位保留，溢出设 C）  
- `0C` DIV（整除，B=0 报错停机）  
- `0D` INC A  
- `0E` DEC A  
- `0F` JMP addr  
- `10` JZ addr  
- `11` JNZ addr  
- `12` JC addr  
- `13` JNC addr  
- `14` JS addr  
- `15` JNS addr  
- `16` OUT（打印 A）  
- `17` NOP

### 逻辑
- `18` AND（A=A&B）  
- `19` OR（A=A|B）  
- `1A` XOR（A=A^B）  
- `1B` NOT（A=~A）

### 位移/循环移位（C 参与/记录）
- `1C` SHL（最高位→C）  
- `1D` SHR（最低位→C）  
- `1E` ROL（(A<<1)|C）  
- `1F` ROR（(A>>1)|C<<7）

### 栈与调用
- `20` PUSH A（或 `push(value)` 内部使用）  
- `21` POP → A  
- `22` CALL addr（压返回地址后跳转；示例按“单字节地址”）  
- `23` RET（弹回 PC）

### 数据传送
- `24` MOV A,B  
- `25` MOV A,C  
- `26` MOV A,D  
- `27` MOV B,A  
- `28` MOV B,C  
- `29` MOV B,D  
- `2A` MOV C,A  
- `2B` MOV C,B  
- `2C` MOV C,D  
- `2D` MOV D,A  
- `2E` MOV D,B  
- `2F` MOV D,C

### 比较/输入
- `30` CMP（A 与 B，设 C/Z/S）  
- `31` IN（从 `input()` 读入到 A，掩 0xFF）

### 中断控制
- `32` EI（允许中断，置 I 标志）  
- `33` DI（禁止中断，清 I 标志）  
- `34` IRET（中断返回，恢复现场）  
- `35` INT #vec（软件触发向量）

---

## 示例程序

演示主程序（加载到 `0x60`）：
```python
main_program = [
    0x32,        # EI
    0x01, 0x00,  # LDA #00
    0x0D,        # INC
    0x07, 0x02,  # JMP 0x02（循环）
]
```

演示中断线程：
```python
# 依次触发：低优先级(I/O, vec=3) → 高优先级(硬故障, vec=1) → 最高优先级(复位, vec=0)
# 观察嵌套打断与 IRET 恢复
```

内置 ISR（由 `setup_interrupt_handlers()` 写入内存）：
- **向量 0（0x20）**：`LDA #0xFF; STA 0xF0; IRET`（系统状态）
- **向量 1（0x30）**：`LDA #0xEE; STA 0xF1; IRET`（错误码）
- **向量 2（0x40）**：`STA 0xF2; INC; IRET`（定时器计数）
- **向量 3（0x50）**：`IN; STA 0xF3; IRET`（I/O 输入）

运行截图（示意输出）：
```
开始执行程序...
中断请求: 向量 3, 优先级 6
处理中断 3 (优先级: 6), 当前优先级: -1
跳转到中断处理程序 0x0050, 嵌套层级: 1
...
触发高优先级中断 (硬件故障)...
处理中断 1 (优先级: 2), 当前优先级: 6
跳转到中断处理程序 0x0030, 嵌套层级: 2
...
触发最高优先级中断 (系统复位)...
处理中断 0 (优先级: 0), 当前优先级: 2
跳转到中断处理程序 0x0020, 嵌套层级: 3
...
最终寄存器状态:
A: 0x?? (...)
...
地址 0xF0: 255 (系统状态)
地址 0xF1: 238 (错误代码)
地址 0xF2: N   (定时器值)
地址 0xF3: M   (输入数据)
```

---

## 扩展与开发

- **新增指令**  
  1. 为指令分配操作码（未占用）  
  2. 在 `instructions` 映射中注册：`self.instructions[0xXX] = self.your_impl`  
  3. 实现在类中添加方法，并在需要时调用 `update_flags()`  

- **增加中断**  
  - 扩展 `interrupt_priorities` 与向量表（`memory[0x00..]`），在 `setup_interrupt_handlers()` 写入新的 ISR  
  - 修改 `trigger_interrupt()` 以支持更多向量（示例当前校验 `0..3`）

- **内存映射 I/O**  
  - 约定地址区间（如 0xF0–0xFF），在 `sta/stb/...` 时触发外设回调

- **测试**  
  - 将 `execute(max_cycles=...)` 设小以便可控  
  - 为每条指令写最小用例：准备寄存器 → 执行指令 → 断言寄存器/标志/内存结果

---

## 常见问题

**Q: 为什么 `IRET` 的弹栈顺序看起来有点“反直觉”？**  
A: 入栈顺序是 `PC low → PC high → FLAGS → current_priority`，出栈必须**逆序**，先优先级、再 FLAGS、再 PC 高/低位，保证状态一致性。

**Q: 为什么 `PC` 只有 8 位寻址？**  
A: 演示中 `PC` 以 16 位保存/压栈，但内存是 8 位寻址（256 字节）。保留高位是为了展示保存现场与扩展空间，简化实现。

**Q: 除法对 0 怎么办？**  
A: `DIV`（0x0C）在 `B==0` 时打印错误并**停止执行**（返回 `False`）。

---

## Roadmap

- [ ] 可选**时钟步进**与单步调试（断点、追踪指令流）  
- [ ] 汇编器/加载器（把助记符编译为字节码）  
- [ ] 更完整的**内存映射 I/O** 示例（如 UART/Timer）  
- [ ] 扩展到 16 位寻址与分页  
- [ ] 指令覆盖率单测

---

## 许可证

建议使用 MIT：在仓库根目录添加 `LICENSE` 文件。

---

## 贡献

欢迎 PR / Issue！  
- 提交前请尽量附带最小复现与期望行为  
- 对新增指令请补充 README 与示例

---

## 致谢

本项目用于教学与练习目的，感谢所有反馈改进建议的同学 🙌

---

### 仓库结构（建议）

```
.
├── priority_interrupt_cpu.py   # 核心 & 示例main
├── README.md                   # 本文件
├── LICENSE                     # 许可证（建议MIT）
└── tests/                      # 可选：单元测试
```
